<!--
Guidance for AI coding assistants working on the Covey.Town repository.
Keep this file concise and focused on discoverable, project-specific patterns.
-->

# Covey.Town — AI assistant quick guide

This repository implements a frontend (Next.js + Phaser) and a backend TownService (Express + Socket.IO).
The following notes capture the most important, discoverable context an AI agent needs to be productive.

- Architecture summary
  - Frontend: `frontend/` — Next.js app using Phaser for the 2D map and Twilio for video. Key files:
    - `frontend/src/App.tsx`, `frontend/pages/index.tsx`, `frontend/src/classes/TownController.ts` — entry points and town client logic
    - `frontend/src/classes/interactable/*` — interactable areas (games, URL inputs, conversation areas)
    - `frontend/src/generated/client` — OpenAPI-generated client for the Towns REST API (generated by `npm run client`)
  - Backend: `townService/` — Express + tsoa-generated REST routes and Socket.IO for realtime.
    - `townService/src/Server.ts` — server bootstrap, Socket.IO integration, and swagger docs endpoint
    - `townService/src/town/*` — Town, ConversationArea, and TownsController implementing REST and socket join logic
  - Shared types: `shared/types/CoveyTownSocket.d.ts` and `shared/generated/swagger.json` — shared type definitions used by both sides.

- Important runtime flows
  - Town creation / listing / management happens over the REST API (`towns` controller + generated OpenAPI client).
  - While in a town, real-time events use Socket.IO. The socket protocol is defined in `shared/types/CoveyTownSocket.d.ts`.
  - The frontend `TownController` maps socket events to higher-level `TownEvents` used throughout React components.

- Developer workflows & commands (explicit)
  - Install dependencies: run `npm install` in each package (`townService`, `frontend`, `shared`) or from repo root run the top-level `npm run install` which chains installs.
  - Start backend in dev: `cd townService && npm run build:live` (this runs nodemon + tsoa auto-generation). The top-level `npm run run-townservice` runs via Heroku local on port 3001.
  - Start frontend dev server: `cd frontend && npm run dev` or from VS Code run the provided npm task "Start frontend Development Server".
  - Generate client bindings: from `frontend` run `npm run client` (reads `../shared/generated/swagger.json` and writes `frontend/src/generated/client`).
  - Tests: frontend and townService use Jest. From package folders run `npm test`. Frontend also supports `npm run test-watch`.
  - Lint/format: `npm run lint` / `npm run format` exist in subprojects.

- Project-specific conventions and patterns
  - Shared type-first approach: runtime socket messages rely on simple object shapes defined in `shared/types/CoveyTownSocket.d.ts` — prefer using those types when changing events.
  - OpenAPI-driven REST client: `frontend/src/generated/client` is generated from `shared/generated/swagger.json`. Regenerate after changing `townService` APIs by running `tsoa spec` (in `townService`) then `npm run client` in `frontend`.
  - Each incoming HTTP request in the backend is handled by a fresh controller instance (tsoa pattern). Global state is managed through `TownsStore` singleton (`townService/src/lib/TownsStore.ts`).
  - Socket rooms use the townID as the room name. The TownsStore factory wires socket.io `to(townID)` broadcasters in `Server.ts`.
  - Frontend interacts with the Towns REST API via a `LoginController`/`townService` wrapper in `frontend/src/contexts` and `frontend/src/hooks` — prefer these helpers instead of calling generated client directly from components.

- Files and locations to inspect for changes
  - Backend API and controllers: `townService/src/town/TownsController.ts`, `townService/src/town/Town.ts`
  - Backend server bootstrap: `townService/src/Server.ts`
  - Shared types & OpenAPI: `shared/types/CoveyTownSocket.d.ts`, `shared/generated/swagger.json`
  - Frontend client generation: `frontend/src/generated/client` and `frontend/package.json` script `client`
  - Frontend town runtime: `frontend/src/classes/TownController.ts`, `frontend/src/hooks`, `frontend/src/components/Town/`

- Typical edits and pitfalls for AI code changes
  - When altering REST endpoints, update tsoa annotations in `townService` controllers, run `npm run swagger`/`tsoa spec`, then regenerate the frontend client (`npm run client`).
  - When adding or renaming socket events, update `shared/types/CoveyTownSocket.d.ts` first and then adjust both `townService` and `frontend` to maintain type compatibility.
  - Tests expect certain environment variables (e.g., Twilio) and test utilities in `townService/TestUtils.ts` and `frontend/setupTests.ts`. Prefer creating mocks in tests rather than requiring real Twilio credentials.
  - Watch out for duplicate TypeScript type roots and the `replace-in-file` scripts used by Stryker (mutation tests) — these are used in `package.json` scripts `stryker-prepare` and `stryker`.

- Quick troubleshooting hints
  - If the frontend can't reach the backend in dev, ensure `NEXT_PUBLIC_TOWNS_SERVICE_URL` is set in `frontend/.env` to `http://localhost:8081` (Server defaults to 8081).
  - Swagger UI served from backend at `/docs` reads `../shared/generated/swagger.json`; confirm relative path if running from a different CWD.
  - If the generated OpenAPI client is missing, run `cd frontend && npm run client` (requires `shared/generated/swagger.json` to be up-to-date).

If any of these areas look incomplete or you want deeper examples (tests, specific component flows), tell me which part to expand and I'll iterate.
